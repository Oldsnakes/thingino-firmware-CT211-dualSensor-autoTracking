#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <string.h>
#include <syslog.h>
#include <signal.h>

#include "Motor.hpp"
#include "Config.hpp"
#include "Logger.hpp"
#include "WorkerUtils.hpp"
#include "globals.hpp"
#include "imp_hal.hpp"
#include <unistd.h>
#include <fcntl.h>

#define MOTOR_DEBUG

#define SV_SOCK_PATH "/dev/md"
#define BUF_SIZE 15

#define PID_SIZE 32

#define MOTOR_INVERT_X 0x1
#define MOTOR_INVERT_Y 0x2
#define MOTOR_INVERT_BOTH 0x3

#if 0
void JSON_initial(motor_message message)
{
  // return all known parameters in JSON string
  // idea is when client page loads in browser we
  // get current details from camera
  printf("{");
  printf("\"status\":\"%d\"", message.status);
  printf(",");
  printf("\"xpos\":\"%d\"", (message).x);
  printf(",");
  printf("\"ypos\":\"%d\"", (message).y);
  printf(",");
  printf("\"xmax\":\"%d\"", (message).x_max_steps);
  printf(",");
  printf("\"ymax\":\"%d\"", (message).y_max_steps);
  printf(",");
  printf("\"speed\":\"%d\"", (message).speed);
  printf(",");
  printf("\"invert\":\"%d\"", (message).inversion_state);
  printf("}");
  printf("\n");
}

void JSON_status(motor_message message)
{
  // return xpos,ypos and status in JSON string
  // allows passing straight back to async call from ptzclient.cgi
  // with little effort and ability to track x,y position
  printf("{");
  printf("\"status\":\"%d\"", (message).status);
  printf(",");
  printf("\"xpos\":\"%d\"", (message).x);
  printf(",");
  printf("\"ypos\":\"%d\"", (message).y);
  printf(",");
  printf("\"speed\":\"%d\"", (message).speed);
  printf(",");
  printf("\"invert\":\"%d\"", (message).inversion_state);
  printf("}");
  printf("\n");
}

void xy_pos(motor_message message)
{
  printf("%d,%d\n", (message).x, (message).y);
}

void show_status(motor_message message)
{
  printf("Max X Steps %d.\n", (message).x_max_steps);
  printf("Max Y Steps %d.\n", (message).y_max_steps);
  printf("Status Move: %d.\n", (message).status);
  printf("X Steps %d.\n", (message).x);
  printf("Y Steps %d.\n",(message).y);
  printf("Speed %d.\n", (message).speed);

  // Report motor inversion status
  if (message->inversion_state == MOTOR_INVERT_BOTH) {
      printf("Motor Inversion: BOTH X and Y are inverted\n");
  } else if (message->inversion_state == MOTOR_INVERT_X) {
      printf("Motor Inversion: X axis is inverted\n");
  } else if (message->inversion_state == MOTOR_INVERT_Y) {
      printf("Motor Inversion: Y axis is inverted\n");
  } else {
      printf("Motor Inversion: OFF\n");
  }
}
#endif
int check_daemon(char *file_name)
{
    FILE *f;
    long pid;
    char pid_buffer[PID_SIZE];

    f = fopen(file_name, "r");
    if(f == NULL)
        return 0;

    if (fgets(pid_buffer, PID_SIZE, f) == NULL) {
        fclose(f);
        return 0;
    }
    fclose(f);

    if (sscanf(pid_buffer, "%ld", &pid) != 1) {
        return 0;
    }

    if (kill(pid, 0) == 0) {
        return 1;
    }

    return 0;
}

void print_request_message(request req)
{
    #ifdef MOTOR_DEBUG
    printf("Sent message: command=%c, type=%c, x=%d, y=%d, speed=%d, speed_supplied=%d\n",
           req->command, req->type, req->x, req->y, req->speed, req->speed_supplied);
    #endif
}

void initialize_request_message(request req) {
    memset(req, 0, sizeof(struct request));
    req->command = 'd'; // Default command
    req->type = 's'; // Default type
    req->x = 0;
    req->got_x = 0;
    req->y = 0;
    req->got_y = 0;
    req->speed = 0;
    req->speed_supplied = false;
}

int motor_init()
{
  char *daemon_pid_file;

  //openlog ("motors app", LOG_PID, LOG_USER);
  daemon_pid_file = "/var/run/motors-daemon";
  if (check_daemon(daemon_pid_file) == 0) {
        LOG_DEBUG("Motors daemon is NOT running, please start the daemon\n");
        return -1;
    }
  //should open socket here
  struct sockaddr_un addr;

  int serverfd = socket(AF_UNIX, SOCK_STREAM, 0);

  if (serverfd == -1) {
      return -1;
  }
  memset(&addr, 0, sizeof(struct sockaddr_un));
  addr.sun_family = AF_UNIX;
  strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);

  //connect to the socket
  if (connect(serverfd, (struct sockaddr *) &addr,sizeof(struct sockaddr_un)) == -1)
      return -1;

  return serverfd;
}
  
// TW: xxxxxxxxxxxxxxxxxxxxxxxxx

int motor_action(char *cmd, int value1) {
  char direction = '\0';
  int stepspeed = 900;
  struct request request_message;

    int serverfd = motor_init();

    request_message.command = *cmd;
    if (serverfd == -1) {
        LOG_DEBUG("Motor socket access failed!");
        return -1;
    }
    initialize_request_message(&request_message);
    switch (*cmd)
    {
        case MOTOR_DIR: //'d';
            direction = static_cast<char>(value1);
            request_message.type = direction;
            switch (direction) 
            {
                case MOTOR_STOP: // stop
                    request_message.type = 's';
                    break;
                case MOTOR_CRUISE: // cruise
                    request_message.type = 'c';
                    break;
                case MOTOR_HOME: // go back 'h'
                    request_message.type = 'b';
                    break;
                case MOTOR_ABS_POS: // set position (absolute movement)
                    request_message.type = 'h';
                    break;
                case MOTOR_REL_POS: // move x y (relative movement)
                    request_message.type = 'g';
                    break;
                default:
                LOG_DEBUG("Invalid Direction Argument: " <<  direction);
    /*
                LOG_DEBUG("Usage : %s -d\n"
                        "\t s (Stop)\n"
                        "\t c (Cruise)\n"
                        "\t b (Go to home position)\n"
                        "\t h (Set position X and Y)\n"
                        "\t g (Steps X and Y)\n",
                        argv[0]);
                exit(EXIT_FAILURE);
    */
            }
            print_request_message(&request_message);
            write(serverfd,&request_message,sizeof(struct request));
            break;
        case MOTOR_SET_SPEED_STEP: //'s';
            stepspeed = value1;
            request_message.speed = stepspeed;
            request_message.speed_supplied = true; // Set speed_supplied to true when speed is provided
            print_request_message(&request_message);
            write(serverfd,&request_message,sizeof(struct request));
            // Ensure the final request uses the correct speed if supplied
            if (request_message.speed_supplied) {
                request_message.speed = stepspeed;
            } else {
                request_message.speed = 0;  // Indicate that speed is not set
            }
            break;
        case MOTOR_X_POS:
            request_message.x = value1;
            request_message.got_x = 1;
            break;
        case MOTOR_Y_POS:
            request_message.y = value1;
            request_message.got_y = 1;
            break;
        case MOTOR_JSON_STATUS: // 'j'
            print_request_message(&request_message);
            write(serverfd,&request_message,sizeof(struct request));

            struct motor_message status;
            read(serverfd,&status,sizeof(struct motor_message));

            //JSON_status(&status);
            break;
        case MOTOR_JSON_ALL:  // 'i'
            // get all initial values
            print_request_message(&request_message);
            write(serverfd,&request_message,sizeof(struct request));
            
            struct motor_message initial;
            read(serverfd,&initial,sizeof(struct motor_message));

            //JSON_initial(&initial);
            break;
        case MOTOR_GET_POSITION:  // 'p'
            print_request_message(&request_message);
            write(serverfd,&request_message,sizeof(struct request));
            
            struct motor_message pos;
            read(serverfd,&pos,sizeof(struct motor_message));

            //xy_pos(&pos);
            break;
        case MOTOR_INIT: // reset 'r'
            print_request_message(&request_message);
            write(serverfd,&request_message,sizeof(struct request));
            break;
        case MOTOR_STATUS: // status'S';
            print_request_message(&request_message);
            write(serverfd,&request_message,sizeof(struct request));
            
            struct motor_message stat;
            read(serverfd,&stat,sizeof(struct motor_message));

            //show_status(&stat);
            break;
        case MOTOR_INV_X: // Invert motor "m"
            request_message.command = 'I';
            request_message.type = 'x'; // Invert X
            print_request_message(&request_message);
            write(serverfd,&request_message,sizeof(struct request));
            break;
        case MOTOR_INV_Y: // Invert motor "n"
            request_message.command = 'I';
            request_message.type = 'y'; // Invert Y
            print_request_message(&request_message);
            write(serverfd,&request_message,sizeof(struct request));
            break;
        case MOTOR_INV_XY:  // "M" both XY
            request_message.command = 'I';
            request_message.type = 'b'; // Invert Y
            print_request_message(&request_message);
            write(serverfd,&request_message,sizeof(struct request));
            break;
        case MOTOR_IS_BUSY: // is moving?  'b';
            print_request_message(&request_message);
            write(serverfd,&request_message,sizeof(struct request));
        
            struct motor_message busy;
            read(serverfd,&busy,sizeof(struct motor_message));
            if(busy.status == MOTOR_IS_RUNNING){
                //LOG_DEBUG("1");
                break;
            } else{
                //LOG_DEBUG("0");
                break;
            }
        default:
            LOG_DEBUG("Invalid MOTOR COMMAND:  " << cmd);
            break;
    }

  if (request_message.command == 'd') {  // excute command
    write(serverfd,&request_message,sizeof(struct request));
  }

}
