#include "Motion.hpp"
// ### TW
#include "ctrls_hal.hpp"
#include "Motor.hpp"

#define MOTION_DEBUG

using namespace std::chrono;
bool ignoreInitialPeriod = true;
int map_h = 8;
int map_v = 6;

static const std::vector<std::string> area_keys = {
    "center",
    "left",
    "right",
    "up",
    "down",
    "up_left",
    "up_right",
    "down_left",
    "down_right"
};

std::string Motion::getConfigPath(const char *itemName)
{
    return "motion." + std::string(itemName);
}

void Motion::detect()
{
    LOG_INFO("Start motion detection thread.");

    int ret;
    int debounce = 0;
    IMP_IVS_MoveOutput *result;
    bool isInCooldown = false;
    auto cooldownEndTime = steady_clock::now();
    auto motionEndTime = steady_clock::now();
    auto startTime = steady_clock::now();
    auto motorMoveEndTime = steady_clock::now();
    auto autoHomeEndTime = steady_clock::now();
    auto isToHome = false;

    int hv_region[map_v][map_h] = {0};

    // ### TW
    std::string gpio_name = "gpio_white";
    bool current_white =  false;

    moving = false;

    int white_pin = ctrls_hal::getGPIO_Pin_byName(gpio_name);

    #ifdef MOTION_DEBUG
        LOG_DEBUG("White Light pin =  " << white_pin);
    #endif 

    #define MOTOR_DH  300
    #define MOTOR_DV  100

    if(init() != 0) return;

    global_motion_thread_signal = true;
    bool tracking_enabled = cfg->motion.tracking_enable;
    bool autoHome_enabled = cfg->motion.autoHome;    
    while (global_motion_thread_signal)
    {
        auto currentTime = steady_clock::now();

        if (global_MipiMode < 3) {  // only work with one sensor
            currentTime = steady_clock::now();
//            if (!tracking_enabled || duration_cast<seconds>(currentTime - motorMoveEndTime).count() < cfg->motion.move_time)
//            {
            ret = IMP_IVS_PollingResult(ivsChn, cfg->motion.ivs_polling_timeout);
            if (ret < 0)
            {
                LOG_WARN("IMP_IVS_PollingResult error: " << ret);
                continue;
            }

            ret = IMP_IVS_GetResult(ivsChn, (void **)&result);
            if (ret < 0)
            {
                LOG_WARN("IMP_IVS_GetResult error: " << ret);
                continue;
            }

            auto elapsedTime = duration_cast<seconds>(currentTime - startTime);
            if (ignoreInitialPeriod && elapsedTime.count() < cfg->motion.init_time)
            {
                continue;
            }
            else
            {
                ignoreInitialPeriod = false;
            }

            if (isInCooldown && duration_cast<seconds>(currentTime - cooldownEndTime).count() < cfg->motion.cooldown_time)
            {
                continue;
            }
            else
            {
                isInCooldown = false;
            }

            bool motionDetected = false;
            std::string msg = "";
            int hit;

            for (int j=0; j < (map_h*map_v); j++) {  // clear hit list
                region[j].hit = 0;
                //hit2hv(&region[j], j, map_h);
                hv_region[region[j].v][region[j].h] = 0;
            }
 
            for (int i = 0; i < IMP_IVS_MOVE_MAX_ROI_CNT; i++)  // 52 regions max
            {
               if (result->retRoi[i])
                {
                    if (!motionDetected) LOG_INFO("Active motion detected in ch: " << ivsChn << " index: " << i);
                    motionDetected = true;
                    hit = box2region(move_param.roiRect[i].p0.x, move_param.roiRect[i].p0.y, move_param.roiRect[i].p1.x, move_param.roiRect[i].p1.y);
                    hit2hv(&region[hit], hit, map_h);
                    region[hit].hit = 1;
                    hv_region[region[hit].v][region[hit].h] = 1;
                    msg = msg + std::to_string(hit) + "[" + std::to_string(region[hit].v) + "," + std::to_string(region[hit].h) + "],";

                    debounce++;
                    if (debounce >= cfg->motion.debounce_time)
                    {
                        if (!moving.load())
                        {
                            moving = true;
                            LOG_INFO(" * Motion Started in roi<" << i << ">");
                            // ### TW
#ifdef MOTION_DEBUG
                            LOG_DEBUG("whiteLight state = " << cfg->motion.whiteLight << " on_time = " << cfg->motion.on_time);
#endif
                            if (cfg->motion.whiteLight) {
                                // preserve current light state
                                current_white = ctrls_hal::getGPIO(white_pin);
                                ctrls_hal::setGPIO(white_pin, true);
                                LOG_DEBUG("white light: " << ((ctrls_hal::getGPIO(white_pin))? "on":"off"));
                            }
#if 1
                            char cmd[128];
                            memset(cmd, 0, sizeof(cmd));
                            snprintf(cmd, sizeof(cmd), "%s start", cfg->motion.script_path);
                            ret = system(cmd);
                            LOG_DEBUG("Send to script:  start");
                            if (ret != 0)
                            {
                                LOG_ERROR("Motion script failed:" << cmd);
                            }
#endif
                        }
                        indicator = true;
                        motionEndTime = steady_clock::now(); // Update last motion time
                    }  // valid
                }  // detected
            }   // rois
#if 1
    #ifdef MOTION_DEBUG
            if (motionDetected) {
                LOG_INFO("Active motion detected in ch: " << ivsChn << " regions: " << msg);

                int i, j;
                LOG_DEBUG("--  Motion Heat Map --");
                msg = "";
                for (i=0; i < map_h; i++) msg = msg+"_"+std::to_string(i)+"_";
                LOG_DEBUG("  . " << msg << " .  ");
                for (j=0; j < map_v; j++) {
                    msg = "";
                    for (i=0; i < map_h; i++) {
                        msg = msg + ((region[i+ j*map_h].hit > 0) ? " * ":" . ");
                        //msg = msg + ((hv_region[j][i]) ? "*":".");
                    }
                    LOG_DEBUG("--| " << msg << " |-" << j << "-");
                }
                msg = "";
                for (i=0; i < map_h; i++) msg = msg+"---";
                LOG_DEBUG("  . " << msg << " .  ");
    #endif                    

                if (cfg->motion.tracking_enable)
                {
                    // weights area of hits
                    msg = "";
                    int hit_total = 0;

                    for (int box=0; box < 9; box++) {
                        box_weight[box] = 0;
                        for (const auto& idx : box_Matrix[box]) {
                            //LOG_DEBUG("box " << box << " - idx: " << idx << " hit = " << region[idx].hit);
                            box_weight[box] += region[idx].hit;
                            hit_total++;
                        }
                        msg = msg + std::to_string(box_weight[box]) + ",";
                    }
                    LOG_DEBUG("area hit weight list(c,l,r,u,d,ul,ur,dl,dw): " <<  msg);
                    if ((box_weight[CENTER] < 6) && (cfg->motion.roi_count /2)) {  // if 50% area hit or center has 6+ hit, not move motor
                        int max_value = 0;
                        int box_idx = 0;
                        // find the area has most hits
                        for (int i = 1; i < 9; i++) {
                            if (box_weight[i] > max_value) 
                            {
                                max_value = box_weight[i];
                                box_idx = i;
                            } 
                        }
                        LOG_DEBUG("*** Hot spot:  " << area_keys[box_idx]);
                        switch (box_idx) {
                            case LEFT:
                                trackTo(-MOTOR_DH, 0);
                                break;
                            case RIGHT:
                                trackTo(MOTOR_DH, 0);
                                break;
                            case UP:
                                trackTo(0, -MOTOR_DV);
                                break;
                            case DOWN:
                                trackTo(0, MOTOR_DV);
                            case UP_LEFT:
                                trackTo(-MOTOR_DH, 0);
                                trackTo(0, -MOTOR_DV);
                                break;
                            case UP_RIGHT:
                                trackTo(MOTOR_DH, 0);
                                trackTo(0, -MOTOR_DV);
                                break;
                            case DOWN_LEFT:
                                trackTo(-MOTOR_DH, 0);
                                trackTo(0, MOTOR_DV);
                                break;
                            case DOWN_RIGHT:
                                trackTo(MOTOR_DH, 0);
                                trackTo(0, MOTOR_DV);
                                break;
                            // case CENTER:  nop
                        }
                        // block the detection for awhile when motor is moving  ***
                        // usleep(cfg->motion.move_time * 1000); // in ms
                        motorMoveEndTime = steady_clock::now(); // Start motor 
                    }
                }
            }
#endif
            if (!motionDetected)
            {
                debounce = 0;
                auto duration = duration_cast<seconds>(currentTime - motionEndTime).count();
                if (moving && duration >= cfg->motion.min_time && duration >= cfg->motion.post_time)
                {
                    LOG_INFO(" # End of Motion");
                    // ### TW - end of light event
                    if (cfg->motion.whiteLight) {
                        // sleep(cfg->motion.on_time);  // in seconds
                        // restore light state
                        ctrls_hal::setGPIO(white_pin, current_white);
                    }

                    if(cfg->motion.autoHome) {
                        autoHomeEndTime = steady_clock::now(); // Start wait 
                        isToHome = true;
                        //sleep(cfg->motion.home_time);  // ***
                        //resetToHome();
                    }
#if 1
                    char cmd[128];
                    memset(cmd, 0, sizeof(cmd));
                    snprintf(cmd, sizeof(cmd), "%s stop", cfg->motion.script_path);
                    ret = system(cmd);
                    if (ret != 0)
                    {
                        LOG_ERROR("Motion script failed:" << cmd);
                    }
#endif
                    moving = false;
                    indicator = false;
                    cooldownEndTime = steady_clock::now(); // Start cooldown
                    isInCooldown = true;
                }
            }

            ret = IMP_IVS_ReleaseResult(ivsChn, (void *)result);
            if (ret < 0)
            {
                LOG_WARN("IMP_IVS_ReleaseResult error: " << ret);
                continue;
            }
        } // motor move block
        if(autoHome_enabled && isToHome && duration_cast<seconds>(currentTime - autoHomeEndTime).count() >= cfg->motion.home_time) {
            resetToHome();
            isToHome = false;
//        }
        }  // not mode 3
    }  // motion detection enabled

    exit();

    LOG_DEBUG("Exit motion detect thread.");
}

int Motion::trackTo(int x, int y) 
{
    char cmd;
    int value = 0;
    cmd = MOTOR_X_POS;
    value = x;
    Motor::motor_action(cmd,value);
    cmd = MOTOR_Y_POS;
    value = y;
    Motor::motor_action(cmd,value);
    cmd = MOTOR_DIR;
    value = MOTOR_REL_POS;
    Motor::motor_action(cmd,value);
    usleep(500000);
    cmd = MOTOR_STATUS;
    value = 0;
    Motor::motor_action(cmd,value);
    return 0;
}

int Motion::resetToHome() 
{
    char cmd;
    int value = 0;
    cmd = MOTOR_DIR;
    value = MOTOR_HOME; 
    Motor::motor_action(cmd,value);
    usleep(1000000);
    cmd = MOTOR_STATUS;
    value = 0;
    Motor::motor_action(cmd,value);
    return 0;
}

/* theory:  
    if center has lot of hits, not moving
    else if one area has full hits, go there
    else if opposit ends both has hits, not moving
    else if same side hits, go the side
    else if corner has hits, go there
*/
int Motion::trackCalculate(int x, int y) {
    return 0;
}

int Motion::hit2hv(box_region *region, int hit, int nh) {
    region->h = hit % nh;
    region->v = (int) hit / nh;
    return 0;
}

//  convert box to region
int Motion::box2region(int x0, int y0, int x1, int y1) {
    int dx = cfg->motion.frame_width / map_h;
    int dy = cfg->motion.frame_height / map_v;
    int hit = 0;

    //LOG_DEBUG("check area: " << x0 << "," << y0 << "-" << x1 << "," << y1 );
    //LOG_DEBUG("dim: W,H,dx,dy = " << cfg->motion.frame_width << "," << cfg->motion.frame_height << "-" << dx << "," << dy << "(" << map_h << "," << map_v << ")");
    int i, j;
	for (j=0; j < map_v; j++) {
		if ( ((j+1)*dy > y0) && ((j*dy) < y1)) {
			for (i=0; i < map_h; i++) {
				if ( ((i+1)*dx > x0) && ((i*dx) < x1)) {
                    // LOG_DEBUG("region matched: " << i+j*map_h << ":" << (i+1)*dx << "," << (j+1)*dy);
					hit = i+j*map_h;	
					// region[i+j*map_h] = 1;	
                    break;
		 		}
			}
		}
	}		 
    return hit;
}


int Motion::init()
{
    LOG_INFO("Initialize motion detection.");

    if((cfg->motion.monitor_stream == 0 && !cfg->stream0.enabled) ||
       (cfg->motion.monitor_stream == 1 && !cfg->stream1.enabled)) {

        LOG_ERROR("Monitor stream is disabled, abort.");
        return -1;
    }
    int ret;

    ret = IMP_IVS_CreateGroup(0);
    LOG_DEBUG_OR_ERROR_AND_EXIT(ret, "IMP_IVS_CreateGroup(0)");

    //automatically set frame size / height
    ret = IMP_Encoder_GetChnAttr(cfg->motion.monitor_stream, &channelAttributes);
    if (ret == 0)
    {
        if (cfg->motion.frame_width == IVS_AUTO_VALUE)
        {
            cfg->set<int>(getConfigPath("frame_width"), channelAttributes.encAttr.picWidth, true);
        }
        if (cfg->motion.frame_height == IVS_AUTO_VALUE)
        {
            cfg->set<int>(getConfigPath("frame_height"), channelAttributes.encAttr.picHeight, true);
        }
        if (cfg->motion.roi_1_x == IVS_AUTO_VALUE)
        {
            cfg->set<int>(getConfigPath("roi_1_x"), channelAttributes.encAttr.picWidth - 1, true);
        }
        if (cfg->motion.roi_1_y == IVS_AUTO_VALUE)
        {
            cfg->set<int>(getConfigPath("roi_1_y"), channelAttributes.encAttr.picHeight - 1, true);
        }
    }

    memset(&move_param, 0, sizeof(IMP_IVS_MoveParam));
    int cnt = 0;
    // OSD is affecting motion for some reason.
    // Sensitivity range is 0-4
    move_param.sense[0] = cfg->motion.sensitivity;
    move_param.skipFrameCnt = cfg->motion.skip_frame_count;
    move_param.frameInfo.width = cfg->motion.frame_width;
    move_param.frameInfo.height = cfg->motion.frame_height;

    LOG_INFO("Motion detection cfg:" <<
             " sensibility: " << move_param.sense[0] <<
             ", skipCnt:" << move_param.skipFrameCnt <<
             ", frame width:" << move_param.frameInfo.width <<
             ", frame height:" << move_param.frameInfo.height);
    if (cfg->motion.mapMode == false) {  // single box roi
        move_param.roiRect[0].p0.x = cfg->motion.roi_0_x;
        move_param.roiRect[0].p0.y = cfg->motion.roi_0_y;
        move_param.roiRect[0].p1.x = cfg->motion.roi_1_x;
        move_param.roiRect[0].p1.y = cfg->motion.roi_1_y;
        move_param.roiRectCnt = 1;
//        move_param.roiRectCnt = cfg->motion.roi_count;
        cnt = move_param.roiRectCnt;
      #if 0
        LOG_INFO("Motion detection roi[0]:" <<
                " roi_0_x: " << cfg->motion.roi_0_x <<
                ", roi_0_y:" << cfg->motion.roi_0_y <<
                ", roi_1_x: " << cfg->motion.roi_1_x <<
                ", roi_1_y:" << cfg->motion.roi_1_y);
      #endif
        LOG_INFO("Box mode - Motion detection roiRect[0]:" <<
             " roi_p0_x: " << move_param.roiRect[0].p0.x <<
             ", roi_p0_y:" << move_param.roiRect[0].p0.y <<
             ", roi_p1_x: " << move_param.roiRect[0].p1.x <<
             ", roi_p1_y: " << move_param.roiRect[0].p1.y <<
             ", roiCount:" <<  move_param.roiRectCnt);
    } else
    {
                cnt = std::min(cfg->motion.roi_count, (int)cfg->motion.rois.size());
                LOG_INFO("Map Mode - cfg ROIs count = " << cnt);
                // LOG_DEBUG("cfg roi count = " << cnt);
                for (int i=0;i < cnt; i++)
                { 
                    const auto &r = cfg->motion.rois[i]; 
                    // LOG_DEBUG("  -- " << i <<  " [x0: " << r.p0_x << " y0: " << r.p0_y << " x1: " << r.p1_x << " y1: " << r.p1_y << "]");
                    move_param.roiRect[i].p0.x = r.p0_x;
                    move_param.roiRect[i].p0.y = r.p0_y;
                    move_param.roiRect[i].p1.x = r.p1_x;
                    move_param.roiRect[i].p1.y = r.p1_y;
                    move_param.sense[i] = cfg->motion.sensitivity;
                }
                move_param.roiRectCnt = cnt;
    }

    // *** if tracking on
    bool tracking_enable = cfg->motion.tracking_enable;

    // ###
    tracking_enable = true;
    
    if (tracking_enable) { // on PTZ
        ctrls_hal::setGPIObyName("gpio_sensor_switch", false);
        LOG_DEBUG("Motion Tracking enabled on PTZ, Auto Home: " << (cfg->motion.autoHome? "true":"false") << " delay = " << cfg->motion.home_time);
    }

    move_intf = IMP_IVS_CreateMoveInterface(&move_param);
    LOG_DEBUG("create interface - Motion detection roi count = " << cnt);
    if (move_intf == NULL) {
        LOG_DEBUG_OR_ERROR(move_intf, "IMP_IVS_CreateMoveInterface(" << ivsChn << ", move_intf)");
        return 1;
    }

    ret = IMP_IVS_CreateChn(ivsChn, move_intf);
    LOG_DEBUG_OR_ERROR_AND_EXIT(ret, "IMP_IVS_CreateChn(" << ivsChn << ", move_intf)");

    ret = IMP_IVS_RegisterChn(ivsGrp, ivsChn);
    LOG_DEBUG_OR_ERROR_AND_EXIT(ret, "IMP_IVS_RegisterChn(" << ivsGrp << ", " << ivsChn << ")");

    ret = IMP_IVS_StartRecvPic(ivsChn);
    LOG_DEBUG_OR_ERROR_AND_EXIT(ret, "IMP_IVS_StartRecvPic(" << ivsChn << ")")

    fs = {
        /**< Device ID */ DEV_ID_FS,
        /**< Group ID */  cfg->motion.monitor_stream,
        /**< output ID */ 1
    };

    ivs_cell = {
        /**< Device ID */ DEV_ID_IVS,
        /**< Group ID */  0,
        /**< output ID */ 0
    };

    ret = IMP_System_Bind(&fs, &ivs_cell);
    LOG_DEBUG_OR_ERROR_AND_EXIT(ret, "IMP_System_Bind(&fs, &ivs_cell)");

    return ret;
}

int Motion::exit()
{
    int ret;

    LOG_DEBUG("Exit motion detection.");

    ret = IMP_IVS_StopRecvPic(ivsChn);
    LOG_DEBUG_OR_ERROR(ret, "IMP_IVS_StopRecvPic(0)");

    ret = IMP_System_UnBind(&fs, &ivs_cell);
    LOG_DEBUG_OR_ERROR_AND_EXIT(ret, "IMP_System_UnBind(&fs, &ivs_cell)");

    ret = IMP_IVS_UnRegisterChn(ivsChn);
    LOG_DEBUG_OR_ERROR(ret, "IMP_IVS_UnRegisterChn(0)");

    ret = IMP_IVS_DestroyChn(ivsChn);
    LOG_DEBUG_OR_ERROR(ret, "IMP_IVS_DestroyChn(0)");

    ret = IMP_IVS_DestroyGroup(ivsGrp);
    LOG_DEBUG_OR_ERROR(ret, "IMP_IVS_DestroyGroup(0)");

    IMP_IVS_DestroyMoveInterface(move_intf);

    return ret;
}

void *Motion::run(void *arg)
{
    ((Motion *)arg)->detect();
    return nullptr;
}
